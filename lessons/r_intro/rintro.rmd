---
title: "R Introduction"
author: "Sarah Meister"
date: 2015-09-16
fontsize: 12pt
geometry: margin=1in
papersize: letterpaper
layout: page
sidebar: false
output: slidy_presentation
---
R is an object-oriented programing language, meaning everything we incounter in R is an object. 

R has several types of objects:

R has a 5 basic classes of objects:

* Character
* Numeric
* Integer
* Complex
* Logical

R has 5 different types of objects:

* Vectors
* Lists
* Matrices
* Factors
* Dataframes

Thus you could have a logical vector, a character dataframe, a numeric matrix, etc. 

# Vectors #

The most basic object is a vector. A vector is a sequence of objects of the same class. We can make vectors using the c() function

```{r}
a <- c(0.4, 1.2)         # numeric
b <- c(TRUE, FALSE)      # logical
c <- c("a","b","c")      # character
d <- c(1L, 2L)           # integer
e <- 1:10                # integer
f <- c(1+0i, 2+4i)       # complex
```

Empty vectors can be made using the vector() function

```{r}
x <- vector("numeric", length=10)
x
```

# Lists #

A list is a special type of vector that can contain objects of different classes. For instance, we can have a list with a numeric dataframe as one object within the list, and a string vector as another. 

```{r}
x <- list(1,"a", TRUE, 1+4i)
x
```

The elements of a list are seperated by double brackets. 
 
# Matrices #
Matrices are vectors with a dimension attribute. The dim attribute is an integer vector of length = 2 (nrow, ncol). 

```{r}
x <- matrix(1:6, nrow=2, ncol=3)

dim(x)

attributes(x)
```
 
Matrices are constructed column-wise, so entries start at the upper left corner and run down the columns. 

Matrices can be created directly from vectors by adding a dimension value

```{r}
x <- 1:10
x
dim(x) <- c(2,5)
x
```

We can also create matrices by column-binding or row-binding with the functions cbind() and rbind()

```{r}
x <- 1:3
y <- 10:12
cbind(x,y)
rbind (x, y)
```

# Factors #

Factors are used to represent catagorical data. They can be ordered or unordered.

* They are like an integer vector where each integer has a label. 
* Factors are more descriptive than integers e.g. "Male" and "Female" vs. 1 and 2
* Factors are treated specially by modelling functions like `lm()` and `glm()`

```{r}
x <- factor(c("yes", "yes", "no", "no", "yes"))
x
table (x)
unclass(x)
```

# Dataframe #

Dataframes are used in R to store tabular data. They are represented in R as a special type of list where every element in the list has the same length. Each element of the list can be thought of as a **column** and each length of the list can be thought of as a **row**. Because a dataframe is a type of list, dataframes can store different classes of objects in each column (e.g. numeric, character, logical, etc.).

Depending on the source of the data, dataframes can be made using the `read.table()`, `read.csv` or `data.frame()` functions. 

```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
nrow(x)
ncol(x)
```


# Attributes #

R objects can have attributes, such as:

* names
* classes
* lengths
* dimensions (matrices/dataframes)
* user defined attributes, such as metadata
* dataframes have a special attribute called `row.names`

Attributes can be modified with the attributes() function, among others.

For example, modifiying the `names` of a vector can make your code more readable.
```{r}
x <- 1:3
names(x)

names(x) <- c("alpha", "beta", "gamma")
x
names(x)
```

# Imputting Tabular Data #

Most data you will work with comes in tabular form (such as an Excel spreadsheet). The two most commonly-used functions used to imput tabular data into R are `read.table()` and `read.csv()`. 
```{r}
data <- read.table(file_name.txt, header=FALSE, sep="\t")

data2 <- read.csv(file_name.csv, header=TRUE)
```

# Outputting Tabular Data #

Often you'll want to save R data into a tabular form (e.g. to view in Excel). This is where you use `write.table()`
```{r}
write.table(data, file= "myfile.csv", sep=",", row.names=TRUE, col.names=FALSE)
```

# Subsetting Data #

Using `[]` in R allows you to subset certain parts of a vector

```{r}
x <- c(TRUE, FALSE, "alpha", "beta", "gamma", 1, 2)

x[c(1, 4, 5)]

x[c("alpha", "gamma")]
```

This also works for matrices
```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
a[c(T, F, T), c("B", "A")]
a[0, -2]
```

and dataframes

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ]  #gives the row of df that is equal to 2

df[ ,c(1, 3)]    #gives the columns that are in position 1 and 3
```

# Functions #

# If-else expressions #

```{r}
if (condition) {
  ##do this
} else {
  ##do that
}

## to add more conditions

if (condition1) {
  ## do this
} else if (condition2) {
  ## do something different
} else {
  ## do something else
}
```

# If #

```{r}
if (x > 3) {
  y <- 10
} else {
  y <- 0
}


### OR


y <- if(x > 3) {
  10
} else {
  0
}
```

# for loop #
```{r}
for (i in 1:10) {
  print (i)
}


### nested for loops

x <- matrix(1:6, 2, 3)

for (i in seq_len(nrow(x))) {
  for (j in seq_len(ncol(x))) {
    print (x[i, j])
  }
}
```
while loop

While loops begin by testing a condition. If it's true, then they execute the loop body. Once the loop has been executed, the condition is tested again, and so forth. Be careful to not make infinite loops (condition to stop never actually occurs)!

```{r}
count <- 0
while (count <10) {
  print (count)
  count <- count + 1
}

## you can also add more than one condition by adding an if else expression in the body
```

# next & return #

`next` is used to skip an iteration of a loop. 

```{r}
for (i in 1:100) {
  if (i <= 20) {
    ## skip the first 20 iterations
    next
  }
  else 
    ## do something here
}
```

# Writing functions #

functions are created using the `function()` directive and are stored as R objects of the class "function". Functions can be passed as arguements to other functions and they can be nested (functions inside functions)

```{r}
f <- function(arguement) {
  ## do something here 
}
```

```{r}
above10 <- function(x) {
  use <- x > 10
  x[use]
}

above <- function(x, n) {
  use <- x > n
  x[use]
}

columnmean <- function (y, remove.NA = TRUE) {
  nc <- ncol(y)
  means <- numeric(nc)
  for (i in 1:nc) {
    means[i] <- mean(y[,i], na.rm = remove.NA)
  }
  means
}
```

# Loop Functions #

R has built loop functions, which often have the word "apply" in them.

- `lapply`: loop over a list and evaluate a function on each element (useful with the `split` function)
- `sapply`: same as `lapply` but it tries to simplify the result
- `apply`: apply a function over the margins of an array 
- `tapply`: apply a function over subsets of a vector
- `mapply`: a multivariate version of lapply 

# lapply #

`lapply` loops internally with C code, making the looping faster

`lapply` takes two to three arguments:
1. a list `x` (or another object that is coerced to a list)
2. a function
3. other arguments as necessary

```{r}
x <- list(a=1:5, b=rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
lapply(x, mean)
```
`lapply` will always return a list

`laaply` and others make heavy use of anonymous functions, which are functions without names.
```{r}
x <- list(a=matrix(1:4,2,2), b=matrix(1:6,3,2))
x

lapply(x, function(ele) ele[ ,1]) 
## create function with the argument ele and then define that argument.
```

# sapply #

`sapply` will try to simplify the result of lapply if possible

- if the result is a list where every element is length 1, than a vector is returned 
- if the result is a list where every element is a vector of the same length, a matrix is returned
- otherwise a list is returned

```{r}
x <- list(a=1:5, b=rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
sapply(x, mean)
```

# apply #

`apply` is used to evalute a function over the margins of an array. It is not faster than a loop, but it works in one line. `1` means do the function to the rows. `2` means 

```{r}
x <- matrix (rnorm(200), 20, 10)
apply(x, 2, mean) # keeping number of columns and collapsing rows. This gives a vector of the means of columns. 

apply(x, 1, sum) # this calculates the sum of all rows

y <- matrix(rnorm(200), 20, 10)

apply(y, 1, quantile, probs = c(0.25, 0.75))

## with an array (stacks of matrices: multidimensional)

a <- array(rnorm(2*2*10), c(2,2,10)) #create an array that looks like a bunch of 2 by 2 matrices and take the mean of those
apply(a, c(1,2), mean) #this keeps the 1st and 2nd dimension

```

# mapply #

mapply is a multivariate apply (like lapply) that applies a function over a set of arguments. 

```{r}
mapply(rep, 1:4. 4:1)

## is the same as

list(rep(1, 4), rep(2,3), rep(3,2), rep(4,1))
```

# Instant Vectorization #

```{r}
noise<- function(n,mean, sd) {
  rnorm(n, mean, sd)
}

noise(5, 1, 2)

mapply(noise, 1:5, 1:5, 2)

## which is the same as

list(noise(1,1,2), noise(2,2,2), noise(3,3,2), noise(4,4,2), noise(5,5,2))
```

# tapply #

`tapply` is used to apply a function over subsets of a vector. 

```{r}
x <- c(rnorm(10), runif(10), rnorm(10,1))
f<- gl(3,10) #factor variable
f

tapply(x, f, mean)

tapply(x, f, range)

```

# split #

`split` is like `tapply`, but without applying the summary statistics. It is useful in conjuction with `lapply` or `sapply`. `split` always returns a list

```{r}
x <- c(rnorm(10), runif(10), rnorm(10,1))
f<- gl(3,10)
split(x, f)

## in conjuction with lapply

lapply(split(x,f), mean)

```

# Splitting a dataframe #

```{r}
library(datasets)
head(airquality)

## calculate the mean within each month

s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[,c("Ozone", "Solar.R", "Wind")]))


sapply(s, function(x) colMeans(x[,c("Ozone", "Solar.R", "Wind")]))

sapply(s, function(x) colMeans(x[,c("Ozone", "Solar.R", "Wind")], na.rm=TRUE))
```