---
title: "R Introduction"
author: "Sarah Meister"
date: 2015-09-16
fontsize: 12pt
geometry: margin=1in
papersize: letterpaper
layout: page
sidebar: false
output: slidy_presentation
---
R is an object-oriented programing language, meaning everything we incounter in R is an object. 

R has several types of objects:


R has a 5 basic classes of objects:

* Character
* Numeric
* Integer
* Complex
* Logical

R has 5 different types of objects:

* Vectors
* Lists
* Matrices
* Factors
* Dataframes

Thus you could have a logical vector, a character dataframe, a numeric matrix, etc. 

# Vectors #

The most basic object is a vector. A vector is a sequence of objects of the same class. We can make vectors using the c() function

```{r}
a <- c(0.4, 1.2)         # numeric
b <- c(TRUE, FALSE)      # logical
c <- c("a","b","c")      # character
d <- c(1L, 2L)           # integer
e <- 1:10                # integer
f <- c(1+0i, 2+4i)       # complex
```

Empty vectors can be made using the vector() function

```{r}
x <- vector("numeric", length=10)
x
```

# Lists #

A list is a special type of vector that can contain objects of different classes. For instance, we can have a list with a numeric dataframe as one object within the list, and a string vector as another. 

```{r}
x <- list(1,"a", TRUE, 1+4i)
x
```

The elements of a list are seperated by double brackets. 
 
# Matrices #
Matrices are vectors with a dimension attribute. The dim attribute is an integer vector of length = 2 (nrow, ncol). 

```{r}
x <- matrix(1:6, nrow=2, ncol=3)

dim(x)

attributes(x)
```
 
Matrices are constructed column-wise, so entries start at the upper left corner and run down the columns. 

Matrices can be created directly from vectors by adding a dimension value

```{r}
x <- 1:10
x
dim(x) <- c(2,5)
x
```

We can also create matrices by column-binding or row-binding with the functions cbind() and rbind()

```{r}
x <- 1:3
y <- 10:12
cbind(x,y)
rbind (x, y)
```

# Factors #

Factors are used to represent catagorical data. They can be ordered or unordered.

* They are like an integer vector where each integer has a label. 
* Factors are more descriptive than integers e.g. "Male" and "Female" vs. 1 and 2
* Factors are treated specially by modelling functions like `lm()` and `glm()`

```{r}
x <- factor(c("yes", "yes", "no", "no", "yes"))
x
table (x)
unclass(x)
```

# Dataframe #

Dataframes are used in R to store tabular data. They are represented in R as a special type of list where every element in the list has the same length. Each element of the list can be thought of as a **column** and each length of the list can be thought of as a **row**. Because a dataframe is a type of list, dataframes can store different classes of objects in each column (e.g. numeric, character, logical, etc.).

Depending on the source of the data, dataframes can be made using the `read.table()`, `read.csv` or `data.frame()` functions. 

```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
nrow(x)
ncol(x)
```


# Attributes #

R objects can have attributes, such as:

* names
* classes
* lengths
* dimensions (matrices/dataframes)
* user defined attributes, such as metadata
* dataframes have a special attribute called `row.names`

Attributes can be modified with the attributes() function, among others.

For example, modifiying the `names` of a vector can make your code more readable.
```{r}
x <- 1:3
names(x)

names(x) <- c("alpha", "beta", "gamma")
x
names(x)
```

# Imputting Tabular Data #

Most data you will work with comes in tabular form (such as an Excel spreadsheet). The two most commonly-used functions used to imput tabular data into R are `read.table()` and `read.csv()`. 
```{r}
data <- read.table(file_name.txt, header=FALSE, sep="\t")

data2 <- read.csv(file_name.csv, header=TRUE)
```

# Outputting Tabular Data #

Often you'll want to save R data into a tabular form (e.g. to view in Excel). This is where you use `write.table()`
```{r}
write.table(data, file= "myfile.csv", sep=",", row.names=TRUE, col.names=FALSE)
```

# Subsetting Data #

Using `[]` in R allows you to subset certain parts of a vector

```{r}
x <- c(TRUE, FALSE, "alpha", "beta", "gamma", 1, 2)

x[c(1, 4, 5)]

x[c("alpha", "gamma")]
```

This also works for matrices
```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")
a[1:2, ]
a[c(T, F, T), c("B", "A")]
a[0, -2]
```

and dataframes

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ]  #gives the row of df that is equal to 2

df[ ,c(1, 3)]    #gives the columns that are in position 1 and 3
```

# Functions #

# If-else expressions #

```{r}
if (condition) {
  ##do this
} else {
  ##do that
}

## to add more conditions

if (condition1) {
  ## do this
} else if (condition2) {
  ## do something different
} else {
  ## do something else
}
```

# If #

```{r}
if (x > 3) {
  y <- 10
} else {
  y <- 0
}


### OR


y <- if(x > 3) {
  10
} else {
  0
}
```

# for loop #
```{r}
for (i in 1:10) {
  print (i)
}


### nested for loops

x <- matrix(1:6, 2, 3)

for (i in seq_len(nrow(x))) {
  for (j in seq_len(ncol(x))) {
    print (x[i, j])
  }
}
```
while loop

While loops begin by testing a condition. If it's true, then they execute the loop body. Once the loop has been executed, the condition is tested again, and so forth. Be careful to not make infinite loops (condition to stop never actually occurs)!

```{r}
count <- 0
while (count <10) {
  print (count)
  count <- count + 1
}

## you can also add more than one condition by adding an if else expression in the body
```

# next & return #

`next` is used to skip an iteration of a loop. 

```{r}
for (i in 1:100) {
  if (i <= 20) {
    ## skip the first 20 iterations
    next
  }
  else 
    ## do something here
}
```

# Writing functions #

functions are created using the `function()` directive and are stored as R objects of the class "function". Functions can be passed as arguements to other functions and they can be nested (functions inside functions)

```{r}
f <- function(arguement) {
  ## do something here 
}
```

```{r}
above10 <- function(x) {
  use <- x > 10
  x[use]
}

above <- function(x, n) {
  use <- x > n
  x[use]
}

columnmean <- function (y, remove.NA = TRUE) {
  nc <- ncol(y)
  means <- numeric(nc)
  for (i in 1:nc) {
    means[i] <- mean(y[,i], na.rm = remove.NA)
  }
  means
}
```